---
description: Code style, vibe-coding principles, and quality standards for XM Cloud starters
alwaysApply: true
globs: []
---

# Code Style

## Vibe-Coding Principles

Core Philosophy:
- Write clean, modular, and idiomatic code
- Prefer declarative over imperative patterns
- Make code readable and self-documenting
- TypeScript-first development approach
- Component-driven architecture with XM Cloud integration

Code Organization:
- Use modern JavaScript/TypeScript features
- Export public types at module boundaries
- Prefer pure functions and thin wrappers
- No top-level side effects (except page entry points)
- Modular architecture with clear separation of concerns

## Code Quality Standards

TypeScript Usage:
- Enable strict mode in all projects
- Prefer explicit types over `any`
- Use discriminated unions for complex state
- Export types at module boundaries for reusability
- Define proper interfaces for XM Cloud data structures

Functional Programming:
- Prefer pure functions where possible
- Use immutable data patterns
- Avoid side effects in business logic
- Compose small, focused functions
- Use React hooks appropriately

Readability:
- Use descriptive variable and function names
- Keep functions small and focused (single responsibility)
- Add JSDoc comments for complex business logic
- Prefer self-documenting code over extensive comments
- Use consistent naming patterns across all starters

## Component Development

React Best Practices:
- Use functional components with hooks
- Implement proper prop validation with TypeScript
- Handle loading and error states explicitly
- Use React.memo for performance optimization when needed
- Follow React 18+ patterns and concurrent features

XM Cloud Component Patterns:
- Always validate field existence before rendering
- Provide meaningful fallbacks for missing content
- Use Sitecore field components for proper rendering
- Handle both editing and preview modes
- Implement proper error boundaries

```typescript
// Good component pattern
interface HeroProps {
  fields: {
    title: Field;
    subtitle: Field;
    backgroundImage: Field;
  };
}

export default function Hero({ fields }: HeroProps) {
  if (!fields) {
    return <div>Hero content not configured</div>;
  }

  return (
    <section className="hero">
      {fields.title && <Text field={fields.title} tag="h1" />}
      {fields.subtitle && <Text field={fields.subtitle} tag="p" />}
      {fields.backgroundImage && <Image field={fields.backgroundImage} />}
    </section>
  );
}
```

## Error Handling

Error Strategy:
- Fail fast with clear, actionable messages
- Provide context in error messages
- Use custom error classes for domain-specific errors
- Handle edge cases explicitly with guard clauses
- Log errors appropriately for debugging

XM Cloud Error Patterns:
- Handle missing datasource gracefully
- Provide fallback content for failed API calls
- Implement proper error boundaries for component failures
- Handle both connected and disconnected mode errors

Security:
- Sanitize user inputs and XM Cloud content
- Validate data at boundaries
- Never log sensitive information
- Use environment variables for all configuration
- Implement proper CSP headers

## Development Workflow

Styling:
- Use Tailwind CSS for consistent styling across starters
- Follow utility-first CSS principles
- Use Shadcn/ui components for common UI elements
- Implement responsive design patterns
- Maintain consistent design tokens

Testing:
- Write tests for component behavior, not implementation
- Mock XM Cloud services in unit tests
- Test error scenarios and edge cases
- Use proper test data that matches XM Cloud structures
- Implement integration tests for critical paths

Imports:
- Use relative imports for local modules
- Group imports logically (external, internal, relative)
- Use barrel exports (index.ts) for clean APIs
- Avoid deep import paths
- Use consistent import ordering

Lint and Format:
- Keep ESLint + Prettier passing at all times
- Follow configured style rules consistently
- Use automated formatting on save
- Address linting warnings promptly
- Maintain consistent code style across all starters

## Performance Considerations

Next.js Optimization:
- Use Next.js Image component for optimized images
- Implement proper ISR patterns for XM Cloud content
- Use dynamic imports for code splitting
- Optimize bundle size with tree shaking
- Implement proper caching strategies

React Performance:
- Use useCallback and useMemo appropriately
- Implement proper key props for list rendering
- Avoid unnecessary re-renders
- Use React.lazy for component lazy loading
- Profile performance in development mode

XM Cloud Performance:
- Cache XM Cloud API responses appropriately
- Use proper loading states for content fetching
- Implement error boundaries to prevent cascade failures
- Consider content freshness vs. performance trade-offs
- Use proper GraphQL query optimization

Referenced:
@examples/kit-nextjs-article-starter/src/components/
@examples/kit-nextjs-location-finder/src/components/
@examples/kit-nextjs-product-listing/src/components/
@examples/basic-nextjs/src/